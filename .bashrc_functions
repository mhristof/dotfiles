
function setup_xdbus {
    local dbus="$HOME/.dbus/Xdbus"
    if [[ ! -f "$dbus" ]]; then
        touch $dbus
        chmod 600 $dbus
        env | grep DBUS_SESSION_BUS_ADDRESS > $dbus
        echo 'export DBUS_SESSION_BUS_ADDRESS' >> $dbus
    fi
}

function d {
    #alias d='hg cdiff'
    local directory="$1"
    if [[ ! -e "$directory" ]]; then
        directory="."
    fi
    git rev-parse --show-toplevel &> /dev/null
    if [[ "$?" -eq 0 ]]; then
        git diff "$directory"
        return
    fi
    hg id &> /dev/null
    if [[ "$?" -eq 0 ]]; then
        hg cdiff "$directory"
        return
    fi
    p4 diff

}

function s {
    #alias s='hg st'
    local directory="$1"
    if [[ ! -d "$directory" ]]; then
        directory="."
    fi
    git rev-parse --show-toplevel &> /dev/null
    if [[ "$?" -eq 0 ]]; then
        git status "$directory"
        return
    fi
    hg st "$directory"
}

function hgp {
    HGP_BACKUP_DIR=$HOME/.backup/patch/
    local name=""
    if [[ $1 ]]; then
        name="_$(echo $* | tr -s ' ' '_')_"
    fi
    local outfile="$(date +'%Y%m%d_%H%M%S')$name.patch"
    hg diff . > $outfile
    [[ -d $HGP_BACKUP_DIR ]] || mkdir -p $HGP_BACKUP_DIR
    cp $outfile $HGP_BACKUP_DIR;
    echo "cp $outfile $HGP_BACKUP_DIR;"
}

HISTORY_TMP=/home/mhristof/.backup/history.txt
function save_last_command {
    echo "$(date) $(hostname) [$(pwd)] $(history | tail -1)" >> $HISTORY_TMP
}

function get_username_color {
    if [[ "$(whoami)" == "root" ]]; then
        echo "\[\e[00;31m\]<><><> ROOT <><><>\[\e[0m\]"
        return
    fi
    local hhash=$(whoami| md5sum | grep "[0-9]" -o | paste -s -d+ - |bc)
    local hash_number=$[ $hhash % 14 ]
    #echo "username $(whoami) hash $hhash hash_number $hash_number"
    case $hash_number in
         0) echo "\[\e[00;37m\]\u\[\e[0m\]";; ## username_white
         1) echo "\[\e[00;31m\]\u\[\e[0m\]";; ## username_red
         2) echo "\[\e[00;32m\]\u\[\e[0m\]";; ## username_green
         3) echo "\[\e[00;33m\]\u\[\e[0m\]";; ## username_yellow
         4) echo "\[\e[00;31m\]\u\[\e[0m\]";; ## username_red
         #4) echo "\[\e[00;34m\]\u\[\e[0m\]";; ## username_blue # not readable
         5) echo "\[\e[00;35m\]\u\[\e[0m\]";; ## username_purple
         6) echo "\[\e[00;35m\]\u\[\e[0m\]";; ## username_cyan
         ## bold colors
         7) echo "\[\e[01;37m\]\u\[\e[0m\]";; ## username_white
         8) echo "\[\e[01;31m\]\u\[\e[0m\]";; ## username_red
         9) echo "\[\e[01;32m\]\u\[\e[0m\]";; ## username_green
        10) echo "\[\e[01;33m\]\u\[\e[0m\]";; ## username_yellow
        11) echo "\[\e[01;31m\]\u\[\e[0m\]";; ## username_red
        #11) echo "\[\e[01;34m\]\u\[\e[0m\]";; ## username_blue # not readable
        12) echo "\[\e[01;35m\]\u\[\e[0m\]";; ## username_purple
        13) echo "\[\e[01;35m\]\u\[\e[0m\]";; ## username_cyan
    esac
}
function get_hostname_color {
    local hhash=$PROMPT_HOSTNAME_COLOR_HASH
    if [[ -z $hhash ]]; then
        hhash=$(hostname | md5sum | grep "[0-9]" -o | paste -s -d+ - |bc)
        export PROMPT_HOSTNAME_COLOR_HASH=$hhash
    fi
    local hash_number=$[ $hhash % 14 ]
    case $hash_number in
         0) echo "\[\e[00;37m\]\h\[\e[0m\]";; ## hostname_white
         1) echo "\[\e[00;31m\]\h\[\e[0m\]";; ## hostname_red
         2) echo "\[\e[00;32m\]\h\[\e[0m\]";; ## hostname_green
         3) echo "\[\e[00;33m\]\h\[\e[0m\]";; ## hostname_yellow
         4) echo "\[\e[00;31m\]\h\[\e[0m\]";; ## hostname_red
         #4) echo "\[\e[00;34m\]\h\[\e[0m\]";; ## hostname_blue # not readable
         5) echo "\[\e[00;35m\]\h\[\e[0m\]";; ## hostname_purple
         6) echo "\[\e[00;35m\]\h\[\e[0m\]";; ## hostname_cyan
         ## bold colors
         7) echo "\[\e[01;37m\]\h\[\e[0m\]";; ## hostname_white
         8) echo "\[\e[01;31m\]\h\[\e[0m\]";; ## hostname_red
         9) echo "\[\e[01;32m\]\h\[\e[0m\]";; ## hostname_green
        10) echo "\[\e[01;33m\]\h\[\e[0m\]";; ## hostname_yellow
        11) echo "\[\e[01;31m\]\h\[\e[0m\]";; ## hostname_red
        #11) echo "\[\e[01;34m\]\h\[\e[0m\]";; ## hostname_blue # not readable
        12) echo "\[\e[01;35m\]\h\[\e[0m\]";; ## hostname_purple
        13) echo "\[\e[01;35m\]\h\[\e[0m\]";; ## hostname_cyan
    esac
}

function update_git_prompt {
    git rev-parse --git-dir &> /dev/null
    if [[ "$?" -ne "0" ]]; then
        GIT_PROMPT=""
        return
    fi

    local git_root="$(basename `git rev-parse --show-toplevel`)"
    local current_branch="$(git branch | grep "^*" | sed 's/^\* //')"
    CURRENT_BRANCH="\[\033[38;5;160m\][$current_branch]\[$(tput sgr0)\]"


    FILE_STATUS=""
    local untracked=$(git ls-files --others --exclude-standard | wc -l)
    if [[ "$untracked" -ne "0" ]]; then
        FILE_STATUS="\[\033[38;5;11m\]?\[$(tput sgr0)\]"
    fi
    local changed="$(git status | grep "modified:" | wc -l)"
    if [[ "$changed" -ne "0" ]]; then
        FILE_STATUS="$FILE_STATUS\[\033[38;5;208m\]++\[$(tput sgr0)\]"
    fi

    local outgoing="$(git log --branches --not --remotes=origin | wc -l)"
    local git_changes=""
    if [[ "$outgoing"  -ne "0" ]]; then
        git_changes=">>>>"
    fi

    GIT_PROMPT="$FILE_STATUS  $git_changes $CURRENT_BRANCH $git_root"
}

function set_prompt {
    update_git_prompt
    local PROMPT_DATE="\[\033[38;5;10m\]\d\[$(tput sgr0)\]\[\033[38;5;15m\] \[$(tput sgr0)\]\[\033[38;5;10m\]\t\[$(tput sgr0)\]"
    local PROMPT_USER_NAME="$(get_username_color)"
    local PROMPT_AT="\[\e[00;37m\]@\[\e[0m\]"
    local PROMPT_HOST="$(get_hostname_color)"
    local PROMPT_PATH="\[\e[00;37m\]\w\[\e[0m\]"
    local EXIT_STATUS_GOOD="\[\e[00;32m\]#\[\e[0m\]"
    local EXIT_STATUS_BAD="\[\e[00;31m\]#\[\e[0m\]"
    local prompt_text="$PROMPT_DATE  $GIT_PROMPT\n$PROMPT_USER_NAME$PROMPT_AT$PROMPT_HOST $PROMPT_PATH"
    if [[ $1 -eq 0 ]]; then
        export PS1="$prompt_text\n$EXIT_STATUS_GOOD"
    else
        export PS1="$prompt_text\n$EXIT_STATUS_BAD"
    fi
}

function prompt {
    set_prompt $?
    save_last_command
}

function c () {
    [ ! $1 ] && cd ~ && ls --color=auto && return 0;
    cd "$1" && ls --color=auto
}

function backup {
    local name="$(date +'%Y%m%d_%H%M%S')"
    local delete=0;
    local source="";
    if [[ "$@" =~ " -d" ]]; then
        source=$(echo $@ | perl -p -i -e 's/ \-d//')
        delete=1;
    elif [[ "$@" =~ "-d " ]]; then
        source=$(echo $@ | perl -p -i -e 's/\-d/ /')
        delete=1;
    else
        source="$1";
    fi
    source=$(echo $source | perl -p -i -e 's/^\s*//' | perl -p -i -e 's/\s*$//');

    source=$(echo $source | perl -p -i -e 's!/$!!')
    if [[ $delete -eq 1 ]]; then
        echo "mv \"$source\" \"$source.$name\"";
        mv "$source" "$source.$name";
    else
        echo "cp -r \"$source\" \"$source.$name\"";
        cp -r "$source" "$source.$name";
    fi
}

function mkrole {
    mkdir -p roles/"$1"/tasks
    mkdir -p roles/"$1"/vars
    mkdir -p roles/"$1"/handlers
    mkdir -p roles/"$1"/templates
    for f in roles/"$1"/handlers/main.yml roles/"$1"/tasks/main.yml ; do
        [[ -f "$f" ]] || echo "---" > "$f"
    done
}

function hist {
    uniq ~/.backup/history.txt > ~/.backup/history.txt.back
    mv ~/.backup/history.txt.back ~/.backup/history.txt
    if [[ -f ~/.backup/history.txt ]]; then
        grep "$1" ~/.backup/history.txt
    else
        history | grep "$1"
    fi
}

function tm {
    tmux new-session -s default -d
    tmux new-window -t default
    tmux new-window -t default
    tmux new-window -t default
    tmux new-window -t default
    tmux kill-window -t default:0
    tmux -2 attach-session -t default:1
}

function vm_get_ip {
    vboxmanage guestproperty enumerate $1 2>&1 | grep "/VirtualBox/GuestInfo/Net/0/V4/IP" | perl -p -e 's/.*value: ([0-9\.]*).*/$1/'
}

function vm {
    case "$1" in
        new)
            local name="$2"
            if [[ -z "$name" ]]; then
                name=test-$(date +'%m-%d-%H-%M')
            fi
            vboxmanage clonevm "ubuntu-server" --register --name $name
            vboxmanage startvm $name --type headless
            sleep 5
            local ip=""
            while [[ -z "$ip" ]]; do
                ip="$(vm_get_ip $name)"
            done
            ssh -oStrictHostKeyChecking=no $ip "sudo hostnamectl set-hostname $name"
            ssh -oStrictHostKeyChecking=no $ip "sudo perl -p -i -e 's/minimal-server-template/$name/ /etc/hosts'"
            echo -e "Host $name ### autogenerated\n    Hostname $ip\n    IdentityFile ~/.ssh/id_rsa" >> ~/.ssh/config
            ;;
        ls|list)
            local running="$(vboxmanage list runningvms | grep -o '{.*}' | tr -s '\n' '|')"
            IFS=$(echo -en "\n\b")
            for f in $(vboxmanage list vms); do
                local name=$(echo "$f" | grep -oP "{.*}")
                local ram=$(vboxmanage showvminfo $name 2>&1 | grep "^Memory")
                if [[ $? -ne 0 ]]; then
                    ram="nada"
                fi
                local ip=$(vm_get_ip $name)
                if [[ $? -ne 0 ]]; then
                    ip=""
                fi
                echo "$f $ram $ip" | GREP_COLOR='1;32' grep -E "$running"
            done
            ;;
        del)
            if [[ -z "$2" ]]; then
                for f in $(vboxmanage list runningvms | cut -d\  -f2); do
                    vboxmanage controlvm "$f" poweroff;
                done
            else
                vboxmanage controlvm "$2" poweroff;
            fi
            ;;
        st)
            local ram_size_mod=$(echo "$@" | grep -oP "\s(\+|\-){0,1}\d*" | tr -d '\n' | tr -d ' ')
            local vm_name="$2"
            echo "$vm_name [$ram_size_mod]"
            if [[ "$ram_size_mod" ]]; then
                # readjust ram
                echo "readjusting"
                local ram_01=$(vboxmanage showvminfo "$vm_name" | grep "^Memory" | cut -d ':' -f2 | perl -p -e 's/\s+//' | perl -p -e 's/MB//')
                local new_ram=$[ $ram_01 + $ram_size_mod ]
                vboxmanage modifyvm "$vm_name" --memory $new_ram
            fi
            vboxmanage startvm "$vm_name" --type headless
            local ip=""
            while [[ -z "$ip" ]]; do
                ip=$(vm_get_ip $vm_name)
            done
            
            # update ip in ssh/config
            local old_ip=$(grep "$vm_name" -A1 ~/.ssh/config | tail -1 | perl -p -e 's/.*Hostname\s+//')
            echo "new ip is $ip - old ip [$old_ip]"
            perl -p -i -e "s/$old_ip/$ip/" ~/.ssh/config
            ;;
    esac
}
